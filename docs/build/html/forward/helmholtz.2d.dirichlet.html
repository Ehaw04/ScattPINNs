
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>Helmholtz equation over a 2D square domain &#8212; ScattPINNs  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="helmholtz-equation-over-a-2d-square-domain">
<h1>Helmholtz equation over a 2D square domain<a class="headerlink" href="#helmholtz-equation-over-a-2d-square-domain" title="Permalink to this headline">¶</a></h1>
<section id="problem-setup">
<h2>Problem setup<a class="headerlink" href="#problem-setup" title="Permalink to this headline">¶</a></h2>
<p>For a wavenumber <span class="math notranslate nohighlight">\(k_0 = 2\pi n\)</span> with <span class="math notranslate nohighlight">\(n = 2\)</span>, we will solve a Helmholtz equation:</p>
<div class="math notranslate nohighlight">
\[- u_{xx}-u_{yy} - k_0^2 u = f, \qquad  \Omega = [0,1]^2\]</div>
<p>with the Dirichlet boundary conditions</p>
<div class="math notranslate nohighlight">
\[u(x,y)=0, \qquad (x,y)\in \partial \Omega\]</div>
<p>and a source term <span class="math notranslate nohighlight">\(f(x,y) = k_0^2 \sin(k_0 x)\sin(k_0 y)\)</span>.</p>
<p>Remark that the exact solution reads:</p>
<div class="math notranslate nohighlight">
\[u(x,y)= \sin(k_0 x)\sin(k_0 y)\]</div>
<p>This example is the Dirichlet boundary condition conterpart to <a class="reference external" href="https://github.com/FEniCS/dolfinx/blob/main/python/demo/helmholtz2D/demo_helmholtz_2d.py">this Dolfinx tutorial</a>. One can refer to Ihlenburg's book &quot;Finite Element Analysis of Acoustic Scattering&quot; p138-139 for more details.</p>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>This description goes through the implementation of a solver for the above described Helmholtz equation step-by-step.</p>
<p>First, the DeepXDE and Numpy modules are imported:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">deepxde</span> <span class="k">as</span> <span class="nn">dde</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>We begin by definying the general parameters for the problem. We use a collocation points density of 10 (resp. 30) points per wavelength for the training (resp. testing) data along each direction.
This code allows to use both soft and hard boundary conditions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">precision_train</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">precision_test</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">hard_constraint</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">weights</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># if hard_constraint == False</span>
</pre></div>
</div>
<p>The PINN will be trained over 5000 epochs. We define the learning rate, the number of dense layers and nodes, and the activation function. Moreover, we import the sine function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">epochs</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="s2">&quot;sin&quot;</span><span class="p">]</span>

<span class="c1"># Define sine function</span>
<span class="k">if</span> <span class="n">dde</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">backend_name</span> <span class="o">==</span> <span class="s2">&quot;pytorch&quot;</span><span class="p">:</span>
    <span class="n">sin</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">pytorch</span><span class="o">.</span><span class="n">sin</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">deepxde.backend</span> <span class="kn">import</span> <span class="n">tf</span>

    <span class="n">sin</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">sin</span>

<span class="n">learning_rate</span><span class="p">,</span> <span class="n">num_dense_layers</span><span class="p">,</span> <span class="n">num_dense_nodes</span><span class="p">,</span> <span class="n">activation</span> <span class="o">=</span> <span class="n">parameters</span>
</pre></div>
</div>
<p>Next, we express the PDE residual of the Helmholtz equation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pde</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">dy_xx</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dy_yy</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">k0</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">k0</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">dy_xx</span> <span class="o">-</span> <span class="n">dy_yy</span> <span class="o">-</span> <span class="n">k0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">-</span> <span class="n">f</span>
</pre></div>
</div>
<p>The first argument to <code class="docutils literal notranslate"><span class="pre">pde</span></code> is the network input, i.e., the <span class="math notranslate nohighlight">\(x\)</span>-coordinate and <span class="math notranslate nohighlight">\(y\)</span>-coordinate. The second argument is the network output, i.e., the solution <span class="math notranslate nohighlight">\(u(x)\)</span>, but here we use <code class="docutils literal notranslate"><span class="pre">y</span></code> as the name of the variable.</p>
<p>Next, we introduce the exact solution and the Dirichlet boundary condition.
If boundary conditions are enforced in a hard fashion, we apply the following transformation to the neural network:</p>
<div class="math notranslate nohighlight">
\[\hat{u}(x,y) = x (x-1) y (y-1) \mathcal{N}(x,y)\]</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k0</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k0</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">*</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>
</pre></div>
</div>
<p>Now, we define the geometry and evaluate the number of training and test random collocation points. The values allow to obtain collocation points density of 10 (resp. 30) points per wavelength along each direction.
For soft boundary conditions, we define the boundary and the Dirichlet boundary conditions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">geom</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">k0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span>
<span class="n">wave_len</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span>

<span class="n">hx_train</span> <span class="o">=</span> <span class="n">wave_len</span> <span class="o">/</span> <span class="n">precision_train</span>
<span class="n">nx_train</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">hx_train</span><span class="p">)</span>

<span class="n">hx_test</span> <span class="o">=</span> <span class="n">wave_len</span> <span class="o">/</span> <span class="n">precision_test</span>
<span class="n">nx_test</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">hx_test</span><span class="p">)</span>

<span class="k">if</span> <span class="n">hard_constraint</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">bc</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">bc</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">icbc</span><span class="o">.</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we generate the training and testing points.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">PDE</span><span class="p">(</span>
    <span class="n">geom</span><span class="p">,</span>
    <span class="n">pde</span><span class="p">,</span>
    <span class="n">bc</span><span class="p">,</span>
    <span class="n">num_domain</span><span class="o">=</span><span class="n">nx_train</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">num_boundary</span><span class="o">=</span><span class="mi">4</span> <span class="o">*</span> <span class="n">nx_train</span><span class="p">,</span>
    <span class="n">solution</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
    <span class="n">num_test</span><span class="o">=</span><span class="n">nx_test</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Next, we choose the network. Here, we use a fully connected neural network of depth 4 (i.e., 3 hidden layers) and width 150. Besides, we choose sin as activation function and Glorot uniform as initializer :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">net</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">FNN</span><span class="p">(</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">num_dense_nodes</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_dense_layers</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">activation</span><span class="p">,</span> <span class="s2">&quot;Glorot uniform&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>For the hard constraint case, we apply the transform to enforce the boundary conditions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">hard_constraint</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">net</span><span class="o">.</span><span class="n">apply_output_transform</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we have the PDE problem and the network. We build a <code class="docutils literal notranslate"><span class="pre">Model</span></code> and define the optimizer and learning rate. When soft constraints are applied, we apply a weight to the boundary term to improve convergence for the ADAM optimizer:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">net</span><span class="p">)</span>

<span class="k">if</span> <span class="n">hard_constraint</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;adam&quot;</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="n">learning_rate</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;l2 relative error&quot;</span><span class="p">])</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">loss_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="p">]</span>
    <span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="s2">&quot;adam&quot;</span><span class="p">,</span>
        <span class="n">lr</span><span class="o">=</span><span class="n">learning_rate</span><span class="p">,</span>
        <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;l2 relative error&quot;</span><span class="p">],</span>
        <span class="n">loss_weights</span><span class="o">=</span><span class="n">loss_weights</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>We first train the model for 5000 iterations with Adam optimizer:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">losshistory</span><span class="p">,</span> <span class="n">train_state</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="complete-code">
<h2>Complete code<a class="headerlink" href="#complete-code" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;Backend supported: tensorflow.compat.v1, tensorflow, pytorch&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">deepxde</span> <span class="k">as</span> <span class="nn">dde</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># General parameters</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">precision_train</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">precision_test</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">hard_constraint</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">weights</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># if hard_constraint == False</span>
<span class="n">epochs</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="s2">&quot;sin&quot;</span><span class="p">]</span>

<span class="c1"># Define sine function</span>
<span class="k">if</span> <span class="n">dde</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">backend_name</span> <span class="o">==</span> <span class="s2">&quot;pytorch&quot;</span><span class="p">:</span>
    <span class="n">sin</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">pytorch</span><span class="o">.</span><span class="n">sin</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">deepxde.backend</span> <span class="kn">import</span> <span class="n">tf</span>

    <span class="n">sin</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">sin</span>

<span class="n">learning_rate</span><span class="p">,</span> <span class="n">num_dense_layers</span><span class="p">,</span> <span class="n">num_dense_nodes</span><span class="p">,</span> <span class="n">activation</span> <span class="o">=</span> <span class="n">parameters</span>


<span class="k">def</span> <span class="nf">pde</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">dy_xx</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dy_yy</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">k0</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">k0</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">dy_xx</span> <span class="o">-</span> <span class="n">dy_yy</span> <span class="o">-</span> <span class="n">k0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">-</span> <span class="n">f</span>


<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k0</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k0</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">*</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>


<span class="n">geom</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">k0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span>
<span class="n">wave_len</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span>

<span class="n">hx_train</span> <span class="o">=</span> <span class="n">wave_len</span> <span class="o">/</span> <span class="n">precision_train</span>
<span class="n">nx_train</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">hx_train</span><span class="p">)</span>

<span class="n">hx_test</span> <span class="o">=</span> <span class="n">wave_len</span> <span class="o">/</span> <span class="n">precision_test</span>
<span class="n">nx_test</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">hx_test</span><span class="p">)</span>

<span class="k">if</span> <span class="n">hard_constraint</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">bc</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">bc</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">icbc</span><span class="o">.</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>


<span class="n">data</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">PDE</span><span class="p">(</span>
    <span class="n">geom</span><span class="p">,</span>
    <span class="n">pde</span><span class="p">,</span>
    <span class="n">bc</span><span class="p">,</span>
    <span class="n">num_domain</span><span class="o">=</span><span class="n">nx_train</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">num_boundary</span><span class="o">=</span><span class="mi">4</span> <span class="o">*</span> <span class="n">nx_train</span><span class="p">,</span>
    <span class="n">solution</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
    <span class="n">num_test</span><span class="o">=</span><span class="n">nx_test</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">net</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">FNN</span><span class="p">(</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">num_dense_nodes</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_dense_layers</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">activation</span><span class="p">,</span> <span class="s2">&quot;Glorot uniform&quot;</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">hard_constraint</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">net</span><span class="o">.</span><span class="n">apply_output_transform</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">net</span><span class="p">)</span>

<span class="k">if</span> <span class="n">hard_constraint</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;adam&quot;</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="n">learning_rate</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;l2 relative error&quot;</span><span class="p">])</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">loss_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="p">]</span>
    <span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="s2">&quot;adam&quot;</span><span class="p">,</span>
        <span class="n">lr</span><span class="o">=</span><span class="n">learning_rate</span><span class="p">,</span>
        <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;l2 relative error&quot;</span><span class="p">],</span>
        <span class="n">loss_weights</span><span class="o">=</span><span class="n">loss_weights</span><span class="p">,</span>
    <span class="p">)</span>


<span class="n">losshistory</span><span class="p">,</span> <span class="n">train_state</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">)</span>
<span class="n">dde</span><span class="o">.</span><span class="n">saveplot</span><span class="p">(</span><span class="n">losshistory</span><span class="p">,</span> <span class="n">train_state</span><span class="p">,</span> <span class="n">issave</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isplot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">ScattPINNs</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Paul Escapil-Inchauspé.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/forward/helmholtz.2d.dirichlet.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>